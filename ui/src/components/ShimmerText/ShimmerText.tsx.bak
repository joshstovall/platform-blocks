import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { ColorValue, LayoutChangeEvent, Platform, StyleSheet, View } from 'react-native';
import MaskedView from '@react-native-masked-view/masked-view';
import { resolveLinearGradient } from '../../utils/optionalDependencies';
import Animated, {
  Easing,
  cancelAnimation,
  runOnJS,
  useAnimatedStyle,
  useSharedValue,
  withDelay,
  withRepeat,
  withSequence,
  withTiming,
  const content = children ?? text ?? null;

  if (!hasLinearGradient || !OptionalLinearGradient) {
    return (
      <View style={[styles.container, spacingStyles]}>
        <Text
          {...textProps}
          color={baseColor}
          onLayout={externalOnLayout}
          style={style}
        >
          {content}
        </Text>
      </View>
    );
  }

  return (
    <ShimmerTextGradient
      textProps={textProps as TextProps}
      baseColor={baseColor}
      colors={colors}
      shimmerColor={shimmerColor}
      duration={duration}
      delay={delay}
      repeatDelay={repeatDelay}
      repeat={repeat}
      once={once}
      direction={direction}
      spread={spread}
      debug={debug}
      externalOnLayout={externalOnLayout}
      style={style}
      content={content}
      spacingStyles={spacingStyles}
    />
  );
      }

interface ShimmerTextGradientProps {
  textProps: TextProps;
  baseColor: string;
  colors?: string[];
  shimmerColor?: string;
  duration: number;
  delay: number;
  repeatDelay: number;
  repeat: boolean;
  once: boolean;
  direction: ShimmerDirection;
  spread: number;
  debug: boolean;
  externalOnLayout?: TextProps['onLayout'];
  style?: TextProps['style'];
  content: React.ReactNode;
  spacingStyles: any;
}

const ShimmerTextGradient: React.FC<ShimmerTextGradientProps> = ({
  textProps,
  baseColor,
  colors,
  shimmerColor,
  duration,
  delay,
  repeatDelay,
  repeat,
  once,
  direction,
  spread,
  debug,
  externalOnLayout,
  style,
  content,
  spacingStyles,
}) => {
  const normalizedSpread = Math.max(spread, MIN_SPREAD);
  const shouldRepeat = repeat && !once;
  const shouldAnimate = once || shouldRepeat;

  const extraDistance = normalizedSpread - 1;
  const minPosition = -extraDistance;
  const maxPosition = 1 + extraDistance;
  const positionRange = maxPosition - minPosition;
  const initialWebPosition = direction === 'rtl' ? maxPosition : minPosition;
  const finalWebPosition = direction === 'rtl' ? minPosition : maxPosition;

  const progress = useSharedValue(0);
  const debugFlag = useSharedValue(debug ? 1 : 0);
  const startX = useSharedValue(0);
  const endX = useSharedValue(0);
  const isWeb = Platform.OS === 'web';

  const [layout, setLayout] = useState({ width: 0, height: 0 });
  const [gradientWidth, setGradientWidth] = useState(0);

      if (!shouldRepeat && activeElapsed >= durationMs) {
        setWebPosition(finalWebPosition);
        finished = true;
        return;
      }

      const cyclePosition = shouldRepeat
        ? activeElapsed % totalCycle
        : Math.min(activeElapsed, durationMs);

      const progressValue = cyclePosition <= durationMs
        ? Math.min(Math.max(cyclePosition / durationMs, 0), 1)
        : 1;

      const positionValue = direction === 'rtl'
        ? maxPosition - progressValue * positionRange
        : minPosition + progressValue * positionRange;
      setWebPosition((prev) => {
        if (Math.abs(prev - positionValue) < 0.001) {
          return prev;
        }
        return positionValue;
      });

      frameId = requestAnimationFrame(step);
    };

    frameId = requestAnimationFrame(step);

    return () => {
      finished = true;
      if (frameId != null) {
        cancelAnimationFrame(frameId);
      }
    };
  }, [isWeb, shouldAnimate, shouldRepeat, duration, delay, repeatDelay, direction, initialWebPosition, finalWebPosition, maxPosition, positionRange, minPosition]);

  const renderNative = () => {
    if (layout.width === 0 || layout.height === 0) {
      return (
        <Text
          {...textProps}
          color={baseColor}
          onLayout={handleLayout}
          style={style}
        >
          {content}
        </Text>
      );
    }

    const LinearGradientComponent = OptionalLinearGradient!;

    return (
      <>
        <Text
          {...textProps}
          color={baseColor}
          onLayout={handleLayout}
          style={style}
        >
          {content}
        </Text>
        <MaskedView
          pointerEvents="none"
          style={[styles.overlay, { width: layout.width, height: layout.height }]}
          maskElement={( 
            <View style={styles.maskWrapper}>
              <Text
                {...textProps}
                color="#000000"
                selectable={false}
                style={overlayBaseStyle}
              >
                {content}
              </Text>
            </View>
          )}
        >
          <View style={[styles.gradientWrapper, { width: layout.width, height: layout.height }]}>
            <Animated.View
              pointerEvents="none"
              style={[{
                position: 'absolute',
                top: 0,
                left: 0,
                width: gradientWidth,
                height: layout.height,
              }, gradientAnimatedStyle]}
            >
              <LinearGradientComponent
                colors={resolvedColors}
                locations={gradientLocations as any}
                start={{ x: direction === 'rtl' ? 1 : 0, y: 0.5 }}
                end={{ x: direction === 'rtl' ? 0 : 1, y: 0.5 }}
                style={styles.linearGradient}
              />
            </Animated.View>
          </View>
        </MaskedView>
      </>
    );
  };

  const renderWeb = () => {
    const gradientColors = resolvedColors.map((color) => String(color));
    const overlayStyle = [
      overlayBaseStyle,
      {
        position: 'absolute' as const,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        width: '100%',
        zIndex: 1,
        display: 'inline-block',
      } as const,
    ];

    return (
      <>
        <GradientText
          {...textProps as any}
          as={(textProps as any)?.as ?? 'span'}
          colors={gradientColors}
          locations={gradientLocations}
          angle={direction === 'rtl' ? 180 : 0}
          position={webPosition}
          animate={false}
          selectable={false}
          style={overlayStyle}
        >
          {content}
        </GradientText>
      </>
    );
  };

  const containerStyle = Platform.OS === 'web'
    ? [styles.container, spacingStyles, { display: 'inline-block' }]
    : [styles.container, spacingStyles];

  return (
    <View style={containerStyle}>
      {Platform.OS === 'web' ? renderWeb() : renderNative()}
    </View>
  );
};

      const elapsed = timestamp - startTime;

      if (elapsed < delayMs) {
        frameId = requestAnimationFrame(step);
        return;
      }

      const activeElapsed = elapsed - delayMs;

      if (!shouldRepeat && activeElapsed >= durationMs) {
        setWebPosition(finalWebPosition);
        finished = true;
        return;
      }

      const cyclePosition = shouldRepeat
        ? activeElapsed % totalCycle
        : Math.min(activeElapsed, durationMs);

      const progressValue = cyclePosition <= durationMs
        ? Math.min(Math.max(cyclePosition / durationMs, 0), 1)
        : 1;

      const positionValue = direction === 'rtl'
        ? maxPosition - progressValue * positionRange
        : minPosition + progressValue * positionRange;
      setWebPosition((prev) => {
        if (Math.abs(prev - positionValue) < 0.001) {
          return prev;
        }
        return positionValue;
      });

      frameId = requestAnimationFrame(step);
    };

    frameId = requestAnimationFrame(step);

    return () => {
      finished = true;
      if (frameId != null) {
        cancelAnimationFrame(frameId);
      }
    };
  }, [isWeb, shouldAnimate, shouldRepeat, duration, delay, repeatDelay, direction, initialWebPosition, finalWebPosition, maxPosition, positionRange, minPosition]);

  const renderNative = () => {
    if (layout.width === 0 || layout.height === 0) {
      return (
        <Text
          {...textProps}
          color={baseColor}
          onLayout={handleLayout}
          style={style}
        >
          {content}
        </Text>
      );
    }

    return (
      <>
        <Text
          {...textProps}
          color={baseColor}
          onLayout={handleLayout}
          style={style}
        >
          {content}
        </Text>
        <MaskedView
          pointerEvents="none"
          style={[styles.overlay, { width: layout.width, height: layout.height }]}
          maskElement={(
            <View style={styles.maskWrapper}>
              <Text
                {...textProps}
                color="#000000"
                selectable={false}
                style={overlayBaseStyle}
              >
                {content}
              </Text>
            </View>
          )}
        >
          <View style={[styles.gradientWrapper, { width: layout.width, height: layout.height }]}>
            <Animated.View
              pointerEvents="none"
              style={[
                {
                  position: 'absolute',
                  top: 0,
                  left: 0,
                  width: gradientWidth,
                  height: layout.height,
                },
                gradientAnimatedStyle,
              ]}
            >
              <OptionalLinearGradient
                colors={resolvedColors}
                locations={gradientLocations as any}
                start={{ x: direction === 'rtl' ? 1 : 0, y: 0.5 }}
                end={{ x: direction === 'rtl' ? 0 : 1, y: 0.5 }}
                style={styles.linearGradient}
              />
            </Animated.View>
          </View>
        </MaskedView>
      </>
    );
  };

  const renderWeb = () => {
    const gradientColors = resolvedColors.map((color) => String(color));
    const overlayStyle = [
      overlayBaseStyle,
      {
        position: 'absolute' as const,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        width: '100%',
        // pointerEvents: 'none' as const,
        zIndex: 1,
        display: 'inline-block',
      } as const,
    ];

    return (
      <>
        <GradientText
          {...textProps as any}
          as={(textProps as any)?.as ?? 'span'}
          colors={gradientColors}
          locations={gradientLocations}
          angle={direction === 'rtl' ? 180 : 0}
          position={webPosition}
          animate={false}
          selectable={false}
          style={overlayStyle}
        >
          {content}
        </GradientText>
      </>
    );
  };

  const containerStyle = Platform.OS === 'web'
    ? [styles.container, spacingStyles, { display: 'inline-block' }]
    : [styles.container, spacingStyles];

  return (
    <View style={containerStyle}>
      {Platform.OS === 'web' ? renderWeb() : renderNative()}
    </View>
  );
}